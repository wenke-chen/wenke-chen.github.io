[{"content":"博客主题 Hugo Theme Stack及 参考文档\n搭建参考教程 1、10分钟教你简单搭建个人博客(hugo篇) 2、10分钟教你简单部署hugo博客(github篇) 搭建教程相关指令 一、安装 Hugo及git\n1 2 Hugo下载链接：https://gohugo.io/getting-started/installing/ git下载链接：https://git-scm.com/downloads 二、创建新站点\n1 hugo new site myblog 这将在当前文件路径下生成一个 myblog 文件夹，里面是一个新的 Hugo 站点结构。\n三、选择并安装主题\n1 https://themes.gohugo.io/ 建议直接将整个github下载为压缩包到本地。\n四、添加内容，新建博客文章指令\n1 hugo new text.md 这将在 content/posts 目录下创建一个新的 Markdown 文件。您可以使用 Markdown 编辑器编辑这个文件，添加文章内容。\n五、本地预览网站\n1 hugo server 这将启动 Hugo 服务器，您可以通过访问 http://localhost:1313 在浏览器中预览您的站点。\n六、构建和部署\n1 hugo 这将在 public 目录下生成您的站点静态文件\n七、创建github仓库并将主题推送至仓库\n在github上创建一个名称叫 https://github.com/yourname/yourname.github.io 的仓库\n1 2 3 4 5 6 7 8 9 # 将生成的静态文件推送到该仓库, 相关信息修改成自己的 # cd public git init git add -A git config --global user.email \u0026#34;you@example.com\u0026#34; git config --global user.name \u0026#34;Your Name\u0026#34; git commit -am \u0026#34;init\u0026#34; git remote add origin https://github.com/wenke-chen/wenke-chen.github.io.git git push -f origin master 推送完成打开https://yourname.github.io/ 即可看到和本地预览一样的博客网站（yourname为您的github名）。\n我的网站是 https://wenke-chen.github.io/\n\u0026#x1f648;\n","date":"2024-02-26T00:00:00Z","image":"https://www.wenke-chen.github.io/p/blog-wizard/hugo_huf9e30f313f804ac0c6bb32294708dd7f_31804_120x120_fill_box_smart1_3.png","permalink":"https://www.wenke-chen.github.io/p/blog-wizard/","title":"博客向导"},{"content":"一、物料清单 物料清单包含所用到的电子件、机械件和3D打印件，并对额外的工具作了说明，本次电机和stm32开发板用的是同一个厂家的产品，电机自带驱动，省去了自写FOC算法，只需熟悉电机通信协议即可对电机有较好的控制，且厂家自带的范例已能应付很多场景。\n二、电气接线图 电机要先配好ID,esp32开发板要先刷好程序再开始组装。\n三、相关算法理论 首先要确定我们要实现功能的先后顺序，即电机转动\u0026ndash;\u0026gt;小车直立\u0026ndash;\u0026gt;小车遥控。\n1、电机转动 本次用的直立算法是LQR,输出的是力矩，所以用电机的MIT模式。\n根据通信协议，我们查看厂家给的CAN控制函数范例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** ************************************************************************ * @brief: mit_ctrl: MIT模式下的电机控制函数 * @param[in]: hcan:\t指向CAN_HandleTypeDef结构的指针，用于指定CAN总线 * @param[in]: motor_id:\t电机ID，指定目标电机 * @param[in]: pos:\t位置给定值 * @param[in]: vel:\t速度给定值 * @param[in]: kp:\t位置比例系数 * @param[in]: kd:\t位置微分系数 * @param[in]: torq:\t转矩给定值 * @retval: void * @details: 通过CAN总线向电机发送MIT模式下的控制帧。 ************************************************************************ **/ void mit_ctrl(hcan_t* hcan, uint16_t motor_id, float pos, float vel,float kp, float kd, float torq) { uint8_t data[8]; uint16_t pos_tmp,vel_tmp,kp_tmp,kd_tmp,tor_tmp; uint16_t id = motor_id + MIT_MODE; pos_tmp = float_to_uint(pos, P_MIN, P_MAX, 16); vel_tmp = float_to_uint(vel, V_MIN, V_MAX, 12); kp_tmp = float_to_uint(kp, KP_MIN, KP_MAX, 12); kd_tmp = float_to_uint(kd, KD_MIN, KD_MAX, 12); tor_tmp = float_to_uint(torq, T_MIN, T_MAX, 12); data[0] = (pos_tmp \u0026gt;\u0026gt; 8); data[1] = pos_tmp; data[2] = (vel_tmp \u0026gt;\u0026gt; 4); data[3] = ((vel_tmp\u0026amp;0xF)\u0026lt;\u0026lt;4)|(kp_tmp\u0026gt;\u0026gt;8); data[4] = kp_tmp; data[5] = (kd_tmp \u0026gt;\u0026gt; 4); data[6] = ((kd_tmp\u0026amp;0xF)\u0026lt;\u0026lt;4)|(tor_tmp\u0026gt;\u0026gt;8); data[7] = tor_tmp; canx_send_data(hcan, id, data, 8); } *MIT命令采用浮点数据等比例转换成整数发送到驱动器，驱动器再将接收到的整数等比例转换成浮点数据。这转换需要用到转换函数float_to_uint，这转换函数需要首先确定两个等比例转换的最大最小值，这两个值可以在上位参数设定页面查询，其中 KP、KD 的最大最小值默认分别为 0.0~500.0、0.0~5.0。Pos、Vel、Torque 分别预设为±12.5、±30、±10，这三个参数可以根据电机的实际参数进行调整。但发送控制命令时，一定要与设定值保持致，否则会控制命令会发生等比例缩放。\n下图是电机MIT模式的控制框图\nMIT模式可实现力矩、位置、速度三者混合控制，在上图中，位置环与速度环是并联形式，这里的位置环与速度环的输出值与前馈力矩t_ff相加得到参考力矩T_ref： 其中:\nT_ref 为参考力矩，单位是 N·m。 kp 为位置增益。kd 为速度增益。 p_des 为电机输出轴的期望位置，单位为 rad。 θm 为电机输出轴的当前位置，单位为 rad。 v_des 为电机输出轴的期望速度，单位为 rad/s。\n为电机输出轴的当前速度，单位为 rad/s。 参考力矩 T_ref 经过 KT_OUT 换算，得到参考电流 iqref，从而进入后续的电流 PI 控制器。\n其中： iqref 为参考电流，单位为 A。\nGR 为电机减速比。\nKt 为减速前的转矩常数，单位是 N·m/A。\nNPP 是极对数。\nflux 磁链，单位是 Wb，可以通过读电机参数得出。\n根据厂家的通信协议，每次发送指令后会有反馈帧，对反馈帧处理可得到包括电机ID、状态、位置、速度、扭矩相关温度参数、寄存器数据等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** ************************************************************************ * @brief: dm4310_fbdata: 获取DM4310电机反馈数据函数 * @param[in]: motor: 指向motor_t结构的指针，包含电机相关信息和反馈数据 * @param[in]: rx_data: 指向包含反馈数据的数组指针 * @param[in]: data_len: 数据长度 * @retval: void * @details: 从接收到的数据中提取DM4310电机的反馈信息，包括电机ID、 * 状态、位置、速度、扭矩相关温度参数、寄存器数据等 ************************************************************************ **/ void dm4310_fbdata(Joint_Motor_t *motor, uint8_t *rx_data,uint32_t data_len) { if(data_len==FDCAN_DLC_BYTES_8) {//返回的数据有8个字节 motor-\u0026gt;para.id = (rx_data[0])\u0026amp;0x0F; motor-\u0026gt;para.state = (rx_data[0])\u0026gt;\u0026gt;4; motor-\u0026gt;para.p_int=(rx_data[1]\u0026lt;\u0026lt;8)|rx_data[2]; motor-\u0026gt;para.v_int=(rx_data[3]\u0026lt;\u0026lt;4)|(rx_data[4]\u0026gt;\u0026gt;4); motor-\u0026gt;para.t_int=((rx_data[4]\u0026amp;0xF)\u0026lt;\u0026lt;8)|rx_data[5]; motor-\u0026gt;para.pos = uint_to_float(motor-\u0026gt;para.p_int, P_MIN, P_MAX, 16); // (-12.5,12.5) motor-\u0026gt;para.vel = uint_to_float(motor-\u0026gt;para.v_int, V_MIN, V_MAX, 12); // (-30.0,30.0) motor-\u0026gt;para.tor = uint_to_float(motor-\u0026gt;para.t_int, T_MIN, T_MAX, 12); // (-10.0,10.0) motor-\u0026gt;para.Tmos = (float)(rx_data[6]); motor-\u0026gt;para.Tcoil = (float)(rx_data[7]); } } 再下一层就是stm32hal库的can初始化和发送接收函数了。\n1 2 3 4 void MX_FDCAN1_Init(void) ... uint8_t canx_send_data(FDCAN_HandleTypeDef *hcan, uint16_t id, uint8_t *data, uint32_t len) .... 2、小车直立 LQR和PID控制算法的对比 对比如下表（摘自网络）。\n特性 LQR PID 控制对象 多变量耦合系统（如小车角度+位置） 单变量系统（如水温） 设计原理 基于数学模型优化（解 Riccati 方程） 基于误差经验调参 核心优势 全局最优 • 多状态自动协调 简单易用 • 无需模型 参数调整 调权重矩阵（Q/R） 调三个系数（Kp/Ki/Kd） 抗干扰能力 ✅ 更强（通过状态权重主动抑制） ❌ 高频噪声易放大 适用系统 线性系统 • 精确建模场景 非线性系统 • 模型未知场景 计算复杂度 离线计算复杂 • 在线计算简单 全程计算简单 典型应用 倒立摆 • 无人机 • 机械臂 温控 • 液位控制 • 电机调速 这里直立算法选择用LQR，后面有时间也会出一版PID的程序。\nLQR数学模型 运动学\n运动学模型主要描述两轮自平衡机器人运动速度、转向和左右两轮速度之间的关系。\n动力学\na.对于车轮\n针对右轮进行受力分析\n车轮的运动可分解为平动和转动，则由牛顿第二定律可得： 由刚体定轴转动定律可得 上式（1）（2）中 m为车轮的质量（kg）；\nr为车轮的半径（m）；\nxR为右轮水平位移（m）；\nHfR为右轮受到地面摩擦力的大小（N）；\nHR为右轮受到车体作用力的水平分力的大小（N）；\nTR为右轮电机输出转矩的大小（N/m）；\nI为车轮的转动惯量（kg/m2）；\nWR为右轮的角度的大小（rad/s）\n联立（1）和（2），消去HfR,可得\n在车轮不打滑的情况下，车轮移动速度的大小和转动速度的大小成比例关系，即\n将方程（4）代入（3）中，可得\n由于左右轮的参数相同，则对左轮也可以得到相似的结果，即\nb.对于车身正向\n小车的正向运动可以分解为前向运动和绕车体质心P的相对转动（俯仰）。小车底盘中心O的水平位移\n将方程（5）和（6）相加后，等式两边处以2可得\n联立方程（7）（8）可得\n对车体，由牛顿第二定律可得 在水平方向上，有\n在竖直方向上，有\n对车体，由刚体定轴转动定律可得\n其中\nM 车体的质量（kg）；\nl 质心距底盘中心的距离（m）；\nJP 车体绕质心转动时的转动惯量（kg/m2）；\nθP车体与竖直方向所成的夹角（rad）；\n联立方程（9）（10）可得\nc.模型线性化\n因为该方程含有非线性项，因此，要进行线性化。考虑到车体的倾角比较小（通常情况下，−10°≤倾角≤10°），则可以认为 故方程（13）变为\n将方程（10）和（11）代入方程（12）中，可得\n类似的，对方程 （15）进行线性化可得\n将方程（16）代入方程（14）中，消去θP二阶导可得\n式中 将方程（14）代入方程（16）中，消去x二阶导可得\n式中 综上所述，对于正向运动有\n对车体，由刚体定轴转动定律可得\nd.转向运动\n转向运动是由于左右两车轮从水平方向上施加给车体的反作用力的大小HL和HR不相等引起的，则由刚体定轴转动定律可得 其中\nd 轮距（m）\nJδ 车体绕y轴转动的转动惯量（kg/）\nδ 小车的偏航角（rad）\n将方程（5）和（6）相减可得\n对车体，由刚体定轴转动定律可得\n小车转向示意图\n当左右两轮运动速度不相等时，小车身转向，如图 2-4 所示。由几何关系可得\n解得\n由方程（23）进一步可得\n联立方程（20）（21）（24）可得\n由方程（19）和（25）可得系统的状态方程为\n左侧的状态变量分别表示小车的位移、前进速度、车体的倾角、车体的角速度、小车的转向角以及转向速度。由于电机输出转矩的大小不好直接控制，则由刚体定轴转动定律将其转化为两个车轮的加速度。\n其中\nVLO左轮无摩擦时线速度的大小（rad/s）\nVRO右轮无摩擦时线速度的大小（rad/s）\n故系统的状态空间表达式变为\n矩阵中的元素为 其中 LQR控制器 最优控制在现代控制理论中有着及其重要的位置，其研究目标是使受控系统的性能指标达到最优时，所需要的基本条件，及其控制的综合方法。 线性二次型（LQR）控制，是一种线性状态反馈控制方法，是最优控制理 论中最成熟、最系统的方法。\n(1)系统状态方程\n(2)性能指标\n(3)反馈增益矩阵K\n(4)Riccati代数方程\n仿真 (1)Simulink模型\n(2)MATLAB代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 clc clear % 模型参数初始化 m=0.178; %车轮的质量 kg r = 0.03375; %车轮的半径 m M = 0.610; %车体的质量 kg I = 0.5*m*r^2; %车轮的转动惯量 l = 0.055; %质心距底盘中心的距离 Jz = (1/3)*M*l*l; %车体绕质心转动时的转动惯量 g=9.8; %重力加速度，单位为m/s^2 %状态空间参数初始化 a=r*(M+2*m+2*I/(r^2)); b=M*r*l; c=Jz+M*l^2; d=M*g*l; e=M*l; A23=-b*d/(a*c-b*e); A43=a*d/(a*c-b*e); B21=(c+b)/(a*c-b*e); B22=(c+b)/(a*c-b*e); B41=-(e+a)/(a*c-b*e); B42=-(e+a)/(a*c-b*e); %状态空间矩阵 A=[0 1 0 0 ; 0 0 A23 0 ; 0 0 0 1; 0 0 A43 0 ] ; %状态矩阵 B=[0 0; B21 B22; 0 0; B41 B42]; %输入矩阵 %系统可控性判断 Co=ctrb(A,B); if(rank(Co)==4) disp(\u0026#39;系统可控\u0026#39;); else disp(\u0026#39;系统不可控\u0026#39;); end %LQR控制器设计 Q = [0.1 0 0 0 ; 0 1 0 0 ; 0 0 70 0 ; 0 0 0 0.05 ]; %权重矩阵 Q 的设计 R = [120 0; 0 120]; %权重矩阵 R 的设计 K=lqr(A,B,Q,R) %调节参数 (3)python代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import numpy as np import control as ctrl # 模型参数初始化 m = 0.178 # 车轮的质量 kg r = 0.03375 # 车轮的半径 m M = 0.610 # 车体的质量 kg I = 0.5 * m * r**2 # 车轮的转动惯量 l = 0.055 # 质心距底盘中心的距离 Jz = (1/3) * M * l * l # 车体绕质心转动时的转动惯量 g = 9.8 # 重力加速度 m/s² # 状态空间参数计算 a = r * (M + 2*m + 2*I/(r**2)) b = M * r * l c = Jz + M * l**2 d = M * g * l e = M * l # 计算中间参数 denominator = a*c - b*e # 公共分母 A23 = -b*d / denominator A43 = a*d / denominator B21 = (c + b) / denominator B22 = B21 # 与 B21 相同 B41 = -(e + a) / denominator B42 = B41 # 与 B41 相同 # 构建状态空间矩阵 A = np.array([ [0, 1, 0, 0], [0, 0, A23, 0], [0, 0, 0, 1], [0, 0, A43, 0] ]) B = np.array([ [0, 0], [B21, B22], [0, 0], [B41, B42] ]) # 检查系统可控性 Co = ctrl.ctrb(A, B) rank = np.linalg.matrix_rank(Co) print(\u0026#34;系统可控\u0026#34; if rank == 4 else \u0026#34;系统不可控\u0026#34;) # LQR控制器设计 Q = np.array([ [0.1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 70, 0], [0, 0, 0, 0.05] ]) R = np.array([ [120, 0], [0, 120] ]) # 计算LQR增益 K, _, _ = ctrl.lqr(A, B, Q, R) print(\u0026#34;\\nLQR增益矩阵 K:\u0026#34;) print(K) (4)实验结果\n核心是调节Q/R矩阵的4个权重值（位置/速度/角度/角速度)\n角度权重 \u0026raquo; 位置权重 (通常10倍以上)\n参考资料 【电机仿真】LQR控制器——二轮平衡小车控制\n超详细!!双轮平衡小车原理分析,文末附STM32源码!\n实物部署 通过LQR矩阵分别与对应的数值差计算再累加，可得出电机的力矩大小，如果只是直立的话，只计算其中一个力矩，另外一个数值即等大反向。\n将程序烧录到小车上后可观察出力矩方向看是否正负反了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 float lqr_k[2][4]={{-0.02041241, -0.09635536, -0.65913956, -0.03197374}, {-0.02041241, -0.09635536, -0.65913956, -0.03197374}}; void ChassisR_task(void) { while(INS.ins_flag==0) {//等待加速度收敛 osDelay(1);\t} ChassisR_init(\u0026amp;chassis_move); while(1) {\tchassisR_feedback_update(\u0026amp;chassis_move,\u0026amp;INS);//更新数据 chassis_move.wheel_motor[1].wheel_T=lqr_k[0][0]*(chassis_move.x_set-chassis_move.x) +lqr_k[0][1]*(chassis_move.v_set-chassis_move.v) +lqr_k[0][2]*(0.03f-chassis_move.myPithR)//0.03rad是机械中值 +lqr_k[0][3]*(chassis_move.d_phi_set-chassis_move.myPithGyroR); chassis_move.wheel_motor[0].wheel_T=-chassis_move.wheel_motor[1].wheel_T; scaled_down(\u0026amp;chassis_move.wheel_motor[0].wheel_T, \u0026amp;chassis_move.wheel_motor[1].wheel_T,-0.1f,0.1f); //限幅，等比例缩放 if(chassis_move.start_flag==1)\t{ mit_ctrl2(\u0026amp;hfdcan1,0x01, 0.0f, 0.0f,0.0f, 0.0f,chassis_move.wheel_motor[0].wheel_T);//左边电机 osDelay(CHASSR_TIME); mit_ctrl2(\u0026amp;hfdcan1,0x02, 0.0f, 0.0f,0.0f, 0.0f,chassis_move.wheel_motor[1].wheel_T);//右边电机 osDelay(CHASSR_TIME); } else if(chassis_move.start_flag==0)\t{ chassis_move.turn_set=chassis_move.total_yaw; mit_ctrl2(\u0026amp;hfdcan1,0x01, 0.0f, 0.0f,0.0f, 0.0f,0.0f);//左边电机\tosDelay(CHASSR_TIME); mit_ctrl2(\u0026amp;hfdcan1,0x02, 0.0f, 0.0f,0.0f, 0.0f,0.0f);//右边电机\tosDelay(CHASSR_TIME); } } } 上面的程序中计算出力矩后还是进行了限幅的操作，防止力矩过大。\n小车成功直立后可微调K矩阵让效果更好\n3、小车遥控 硬件及遥控数据接收程序\n小车遥控的接收板选用的是带蓝牙wifi的wsp32，既可以实现2.4g网络遥控，也可以通过蓝牙遥控，价格也不比单独的蓝牙模块贵。\n手柄选用的是国产xbox系列的，刚好github上有网友分享了xbox+esp32的程序，稍微改下即可使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void loop() { xboxController.onLoop(); delay(50);# 控制发送频率 if ((xboxController.xboxNotif.btnStart == 1) \u0026amp;\u0026amp; (last_start != xboxController.xboxNotif.btnStart)) if (start == 0) start = 1; else start = 0; last_start = xboxController.xboxNotif.btnStart; if (xboxController.isConnected() \u0026amp;\u0026amp; (start == 1)) { if (xboxController.isWaitingForFirstNotification()) { Serial.println(\u0026#34;waiting for first notification\u0026#34;); } else { Serial.print(xbox_string()); } } else if (!xboxController.isConnected() \u0026amp;\u0026amp; (start == 1)) { Serial.println(\u0026#34;not connected\u0026#34;); if (xboxController.getCountFailedConnection() \u0026gt; 2) { ESP.restart(); } } } 我这里改的地方是增加延时来控制发送频率，另外增加了按键来控制是否发送手柄数据到串口。\n最后增加个freertos的任务专门处理手柄数据即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 void Xbox_task(void) { if (esp32_rx_flag) { // 清除接收完成标志 esp32_rx_flag = 0; // 确保数据结尾有换行符 if (esp32_rx_len \u0026gt; 0 \u0026amp;\u0026amp; esp32_rx_buffer[esp32_rx_len - 1] == \u0026#39;\\n\u0026#39;) { // 复制数据到临时缓冲区，并添加字符串结束符 char temp_buffer[ESP32_RX_BUFFER_SIZE]; // 排除 \u0026#39;\\n\u0026#39;，只复制中间的数据部分 strncpy(temp_buffer, (char*)esp32_rx_buffer, esp32_rx_len - 1); temp_buffer[esp32_rx_len - 1] = \u0026#39;\\0\u0026#39;; char *token; char *rest = temp_buffer; int data_index = 0; // 解析所有22个数据 while ((token = strtok_r(rest, \u0026#34;,\u0026#34;, \u0026amp;rest)) != NULL) { switch (data_index) { case 0: xbox_controller_data.btnY = atoi(token); break; case 1: xbox_controller_data.btnX = atoi(token); break; case 2: xbox_controller_data.btnB = atoi(token); break; case 3: xbox_controller_data.btnA = atoi(token); break; case 4: xbox_controller_data.btnLB = atoi(token); break; case 5: xbox_controller_data.btnRB = atoi(token); break; case 6: xbox_controller_data.btnSelect = atoi(token); break; case 7: xbox_controller_data.btnStart = atoi(token); break; case 8: xbox_controller_data.btnXbox = atoi(token); break; case 9: xbox_controller_data.btnShare = atoi(token); break; case 10: xbox_controller_data.btnLS = atoi(token); break; case 11: xbox_controller_data.btnRS = atoi(token); break; case 12: xbox_controller_data.btnDirUp = atoi(token); break; case 13: xbox_controller_data.btnDirRight = atoi(token); break; case 14: xbox_controller_data.btnDirDown = atoi(token); break; case 15: xbox_controller_data.btnDirLeft = atoi(token); break; case 16: xbox_controller_data.joyLHori = atoi(token); break; case 17: xbox_controller_data.joyLVert = atoi(token); break; case 18: xbox_controller_data.joyRHori = atoi(token); break; case 19: xbox_controller_data.joyRVert = atoi(token); break; case 20: xbox_controller_data.trigLT = atoi(token); break; case 21: xbox_controller_data.trigRT = atoi(token); break; default: break; } data_index++; } if(xbox_controller_data.btnY == 1 \u0026amp;\u0026amp; start_flag == 0) {//启动 chassis_move.start_flag=1; start_flag = 1; } else if(xbox_controller_data.btnY == 1 \u0026amp;\u0026amp; start_flag == 1) {//停止 chassis_move.start_flag=0; start_flag = 0; } if(chassis_move.start_flag==1) { if(xbox_controller_data.btnB == 1 \u0026amp;\u0026amp; pause_flag == 0) {//暂停 chassis_move.front_flag=0; chassis_move.turn_flag=0; chassis_move.v_set=0.0f; chassis_move.turn_set=chassis_move.total_yaw; } else if(xbox_controller_data.btnDirUp == 1) {//前进 chassis_move.front_flag=1; chassis_move.v_set=5.0f*vel_ratio; chassis_move.x_set=chassis_move.x_set+chassis_move.v_set*0.02f;\t} else if(xbox_controller_data.btnDirDown == 1) {//后退 chassis_move.front_flag=1; chassis_move.v_set=-5.0f*vel_ratio; chassis_move.x_set=chassis_move.x_set+chassis_move.v_set*0.02f;\t} else if(xbox_controller_data.btnDirLeft == 1) {//左转 chassis_move.turn_flag=1; chassis_move.turn_set=10.0f*vel_ratio; } else if(xbox_controller_data.btnDirRight == 1) {//右转 chassis_move.turn_flag=1; chassis_move.turn_set=-10.0f*vel_ratio; } else if(xbox_controller_data.btnLB == 1) { vel_ratio-=0.05f; // 将 vel_ratio 限制在 [0.2, 0.6] 范围内 vel_ratio=(vel_ratio \u0026lt; 0.2f) ? 0.2f : ((vel_ratio \u0026gt; 0.6f) ? 0.6f : vel_ratio); } else if(xbox_controller_data.btnRB == 1) { vel_ratio+=0.05f; // 将 vel_ratio 限制在 [0.2, 0.6] 范围内 vel_ratio=(vel_ratio \u0026lt; 0.2f) ? 0.2f : ((vel_ratio \u0026gt; 0.6f) ? 0.6f : vel_ratio); } else {//暂停 chassis_move.front_flag=0; chassis_move.turn_flag=0; chassis_move.v_set=0.0f; chassis_move.turn_set=chassis_move.total_yaw; } pause_flag = xbox_controller_data.btnB; }\t} } osDelay(1); } 遥控数据处理程序\n基于直立的程序进行修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 float Turn_Kp=0.03f; float Turn_Kd=0.12; //转向环 float Turn(float Angle,float Gyro) { float tor3; if(chassis_move.turn_flag==1) { tor3=(chassis_move.turn_set-Gyro)*Turn_Kd; } else if(chassis_move.turn_flag==0) { tor3=Turn_Kp*(chassis_move.turn_set-Angle)-Gyro*Turn_Kd; } return tor3; } void ChassisR_task(void) { while(INS.ins_flag==0) {//等待加速度收敛 osDelay(1);\t} ChassisR_init(\u0026amp;chassis_move); while(1) {\tchassisR_feedback_update(\u0026amp;chassis_move,\u0026amp;INS);//更新数据 chassis_move.wheel_motor[0].wheel_T=lqr_k[0][0]*(chassis_move.x_set-chassis_move.x) +lqr_k[0][1]*(chassis_move.v_set-chassis_move.v) +lqr_k[0][2]*(0.03f-chassis_move.myPithR)//0.03rad是机械中值 +lqr_k[0][3]*(chassis_move.d_phi_set-chassis_move.myPithGyroR); chassis_move.wheel_motor[1].wheel_T=lqr_k[1][0]*(chassis_move.x_set-chassis_move.x) +lqr_k[1][1]*(chassis_move.v_set-chassis_move.v) +lqr_k[1][2]*(0.03f-chassis_move.myPithR)//0.03rad是机械中值 +lqr_k[1][3]*(chassis_move.d_phi_set-chassis_move.myPithGyroR); chassis_move.wheel_motor[0].wheel_T=0.0f-chassis_move.wheel_motor[0].wheel_T; turn_T= Turn(chassis_move.total_yaw,INS.Gyro[2]); chassis_move.wheel_motor[0].wheel_T=chassis_move.wheel_motor[0].wheel_T-turn_T; chassis_move.wheel_motor[1].wheel_T=chassis_move.wheel_motor[1].wheel_T-turn_T; scaled_down(\u0026amp;chassis_move.wheel_motor[0].wheel_T, \u0026amp;chassis_move.wheel_motor[1].wheel_T,-0.1f,0.1f); if(chassis_move.start_flag==1)\t{ mit_ctrl2(\u0026amp;hfdcan1,0x01, 0.0f, 0.0f,0.0f, 0.0f,chassis_move.wheel_motor[0].wheel_T);//左边电机 osDelay(CHASSR_TIME); mit_ctrl2(\u0026amp;hfdcan1,0x02, 0.0f, 0.0f,0.0f, 0.0f,chassis_move.wheel_motor[1].wheel_T);//右边电机 osDelay(CHASSR_TIME); } else if(chassis_move.start_flag==0)\t{ chassis_move.turn_set=chassis_move.total_yaw; mit_ctrl2(\u0026amp;hfdcan1,0x01, 0.0f, 0.0f,0.0f, 0.0f,0.0f);//左边电机\tosDelay(CHASSR_TIME); mit_ctrl2(\u0026amp;hfdcan1,0x02, 0.0f, 0.0f,0.0f, 0.0f,0.0f);//右边电机\tosDelay(CHASSR_TIME); } } } 四、调试心得 现象 根本原因 解决方案 高频抖动 (\u0026gt;10Hz) 速度项权重不足 ↑ Q1 / ↑ Q3 低频摇摆 (0.5~2Hz) R值过大或位置权重过高 ↓ R 或 ↓ Q0 受扰恢复慢 (\u0026gt;1s) 角度权重不足 ↑ Q2 电机发烫 R值过小 ↑ R 位置持续漂移 位置权重过低 ↑ Q[0] 同时 ↑ R 防抖 五、实物展示 实物中为方便调试加入了lcd显示屏和无线仿真器，并将外观做成了类似小米9号平衡车的样子。 所涉及资料都已放在github，有需要可自行下载。\n所用代码、BOM及3D文件 https://github.com/wenke-chen/DM-segway\n","date":"2025-07-11T22:47:51+08:00","image":"https://www.wenke-chen.github.io/p/segway/car_huedaa8f5f72a7c1929b4fa5b365acec86_54738_120x120_fill_box_smart1_3.png","permalink":"https://www.wenke-chen.github.io/p/segway/","title":"基于无刷电机的平衡小车"},{"content":"引言 艾利·高德拉特的《目标》系列不仅仅是关于生产管理和项目管理的书籍，它们是关于如何在生活和工作中实现目标的深刻洞察。通过这一系列的阅读，我不仅学到了约束理论（Theory of Constraints, TOC）的精髓，还对如何设定和实现目标有了全新的认识。\n《目标》：效率的启示 《目标》作为系列的开篇，通过亚历克斯·罗杰斯的故事，展示了如何识别和解决生产过程中的瓶颈。这本书让我意识到，真正的效率来自于对目标的清晰认识和对瓶颈的精准打击。\n故事背景 主角：亚历克斯·罗格（Alex Rogo），一位面临巨大工作压力的工厂经理。 工厂：工厂正面临严重的财务问题，亚历克斯必须在三个月内改善工厂的运营状况，否则工厂将被关闭。 主要内容 问题识别：亚历克斯在工厂运营中遇到了多个问题，包括生产效率低下、库存积压、订单延迟等。\n导师出现：亚历克斯遇到了一位神秘的导师，乔纳（Jonah），他开始向亚历克斯传授TOC的基本原理。\nTOC原则：乔纳向亚历克斯解释了TOC的五个核心步骤，这些步骤旨在帮助他识别和解决工厂的瓶颈问题。\n识别系统的制约：找出限制系统产出的瓶颈。 决定如何利用制约：最大化瓶颈资源的利用。 其他一切服从上述决定：调整其他所有操作以支持瓶颈资源。 提升制约：如果可能，消除瓶颈。 如果制约被打破，回到第一步：持续改进。 实施变革：亚历克斯开始在工厂实施TOC原则，逐步解决生产瓶颈，提高效率。\n个人生活：亚历克斯在工作的同时，也面临着家庭问题。书中也探讨了如何将TOC的原则应用于个人生活中。\n结果 亚历克斯成功地改善了工厂的运营，提高了生产效率，减少了库存，缩短了交货时间，并且改善了财务状况。 他的个人生活也得到了改善，因为他学会了如何更好地管理时间和精力。 核心理念 制约理论：任何系统都存在至少一个制约因素，识别并管理这些制约因素是提高系统整体性能的关键。 因果关系：书中强调了理解因果关系的重要性，以及如何通过逻辑推理来解决问题。 持续改进：TOC强调持续改进和适应变化，而不是寻找一劳永逸的解决方案。 《目标》不仅是一部管理学书籍，它也是一部励志小说，通过亚历克斯的故事，鼓励读者在面对挑战时保持积极的态度，并通过系统性的思考来找到解决问题的方法。这本书对于希望提高个人和组织效率的读者来说，提供了宝贵的见解和工具。\n《绝不是靠运气》：持续改进的艺术 在《绝不是靠运气》中，亚历克斯的旅程继续，他将TOC的原则应用于更广泛的领域，包括家庭和个人生活。这本书教会了我，持续改进是一个永无止境的过程，它要求我们不断地审视和调整自己的行动。\n故事背景 主角：亚历克斯·罗格（Alex Rogo），在《目标》中成功改善了工厂运营的经理，现在升职为管理三家公司的高管。 挑战：亚历克斯面临的新挑战是如何在更广泛的业务领域中应用TOC（Theory of Constraints，制约理论）原则，包括营销、销售、研发和分销等。 主要内容 营销和分销：书中以企业产品的营销和分销为主线，探讨了如何在这些领域中识别和解决制约因素。 TOC的应用：亚历克斯在新的职位上，继续运用TOC的原则来解决更复杂的管理问题，包括如何提高市场竞争力、优化分销网络、处理客户关系等。 思维工具：书中介绍了TOC的思维工具，如现状图、冲突图、未来图等，这些工具帮助亚历克斯分析问题、制定策略并实施改进。 个人生活：亚历克斯在处理工作挑战的同时，也面临着家庭和个人生活的挑战，书中展示了他如何在事业和家庭之间寻求平衡。 结果 亚历克斯成功地将TOC原则应用于营销和分销领域，提高了企业的市场表现和盈利能力。 他通过TOC的思维工具，有效地解决了个人生活中的冲突，实现了事业和家庭的双赢。 核心理念 系统思维：书中强调了系统思维的重要性，即认识到企业各个部分之间的相互依赖和影响。 逻辑推理：TOC的逻辑推理方法被用来分析和解决问题，而不是依赖直觉或运气。 持续改进：亚历克斯的故事展示了持续改进的重要性，以及如何通过不断的学习和适应来应对变化。 《绝不是靠运气》通过亚历克斯的故事，向读者展示了TOC原则在更广泛领域的应用，以及如何通过系统性的思考和逻辑推理来提高个人和组织的效率。这本书对于那些希望在商业和管理领域取得成功的人来说，提供了实用的工具和深刻的见解。\n《仍然不足够》：目标的深化 《仍然不足够》进一步深化了目标的概念，亚历克斯面临的挑战更加复杂。这本书让我认识到，即使在取得成就之后，我们仍然需要设定新的目标，并为之努力。\n核心观点 信息技术的作用：书中强调信息技术能够显著改善企业运营，但仅仅拥有信息技术并不足以实现企业的全部潜力。 TOC制约法：TOC（Theory of Constraints）制约法揭示了企业信息化后的新经营境界，指出了信息技术的限制往往源自人们在科技出现之前就已经习惯的运作规则。 故事背景 主角：亚历克斯·罗格（Alex Rogo），在前作中成功应用TOC原则的经理，现在面临新的挑战。 挑战：亚历克斯需要解决信息技术在企业中的应用问题，特别是在ERP（企业资源规划）系统的实施和管理上。 主要内容 ERP系统的困境：书中描述了企业在实施ERP系统后遇到的问题，如市场饱和、客户需求不断变化导致系统复杂化，以及IT投资的回报问题。 TOC在ERP中的应用：亚历克斯运用TOC原则来优化ERP系统，提高企业的盈利能力和运营效率。 管理矛盾：书中探讨了ERP供应商在满足客户需求与简化系统之间的矛盾，以及如何通过TOC原则解决这些矛盾。 生产管理：书中还讨论了生产管理中的问题，如如何合理安排生产排程，以及如何通过缓冲管理来提高生产稳定性。 结果 亚历克斯成功地将TOC原则应用于ERP系统的管理，解决了企业在信息技术应用上的困境，提高了企业的盈利能力。 核心理念 科技与人性：科技的发展需要结合人性和企业的运作规则，才能发挥最大的效益。 持续改进：企业需要不断地审视和改进其运作规则，以适应信息技术的发展。 系统思维：企业应采用系统思维来理解和管理复杂的ERP系统，确保各个部分协同工作。 《仍然不足够》通过亚历克斯的故事，向读者展示了如何将TOC原则应用于信息技术领域，特别是ERP系统的实施和管理，以及如何通过改变运作规则来提高企业的整体效率和盈利能力。\n《关键链》：项目管理的新视角 《关键链》引入了关键链方法，这是一种全新的项目管理技术。它通过资源平衡和缓冲管理，帮助项目经理更有效地控制项目风险，确保项目按时完成。\n核心观点 项目管理革新：《关键链》提出了一种新的项目管理方法——关键链项目管理（CCPM），旨在改进和替代传统的CPM（关键路径法）。 资源限制：书中强调了在项目管理中考虑资源限制的重要性，以及如何通过关键链方法更有效地分配和管理资源。 不确定性管理：介绍了如何在项目计划中考虑不确定性，并通过缓冲管理来减少风险。 故事背景 主角：李查德，一位在商学院任教多年的教授，面临职业发展的瓶颈。 情境：李查德在努力晋升为永久系教授的过程中，接触到了关键链项目管理的概念，并开始探索其在实际工作中的应用。 主要内容 传统方法的局限：书中通过李查德的经历，展示了传统项目管理方法在处理资源冲突和不确定性时的不足。 关键链方法的介绍：李查德学习并应用关键链方法，这种方法通过识别项目中的关键链（资源受限的任务序列）来安排项目计划。 实践与挑战：李查德在实际项目中尝试应用关键链方法，面对各种挑战，如资源分配、项目进度控制和团队协作。 结果 李查德通过关键链方法成功地提高了项目管理的效率，减少了项目延误，提升了团队的士气和效率。 核心理念 资源优化：项目管理应关注资源的合理分配和优化，以提高整体项目的性能。 系统思维：采用系统思维来理解和管理项目，确保各个部分协同工作，实现项目目标。 持续改进：项目管理是一个动态过程，需要不断地监控、评估和调整计划。 《关键链》通过李查德的故事，向读者展示了关键链项目管理方法如何帮助项目经理更有效地管理复杂项目，尤其是在资源有限和存在不确定性的情况下。\n《醒悟》：个人成长的反思 《醒悟》（假设这是高德拉特的一本书，实际上可能不存在这本书）可能是关于个人成长和自我反思的探索。它可能引导读者如何在个人生活中应用TOC的原则，以实现更深层次的自我提升。\n核心观点 管理哲学：《醒悟》通过一个零售业的故事，探讨了艾利·高德拉特的管理哲学和TOC（Theory of Constraints，制约理论）的应用。 因果关系：书中强调了理解行动与结果之间的因果关系，以及如何通过改变管理概念来解决复杂的管理问题。 故事背景 主角：淮德，汉娜零售集团佛罗里达州博卡拉顿滩分店的经理，面临职业和个人生活的挑战。 情境：淮德不想依靠家族背景成为高管，而是希望通过自己的努力证明自己的能力。 主要内容 管理困境：淮德在管理分店时遇到了各种挑战，包括库存管理、销售目标、员工激励等问题。 苏格拉底式的问题：书中通过一系列苏格拉底式的问题引导读者和淮德一起思考，从而找到解决问题的方法。 TOC的应用：淮德在故事中应用TOC的原则，逐步改善了分店的运营状况，提高了效率和盈利能力。 结果 淮德通过理解和应用TOC的原则，成功地解决了分店的运营问题，实现了个人职业的成长和分店业绩的提升。 核心理念 因果逻辑：强调在管理决策中应用因果逻辑，以确保行动能够有效地导致期望的结果。 系统思维：鼓励管理者采用系统思维，识别并解决制约系统性能的关键因素。 持续改进：倡导持续改进的管理理念，通过不断的学习和实践来提升管理水平。 《醒悟》通过淮德的故事，展示了TOC理论在实际管理中的应用，以及如何通过改变思维方式来解决看似复杂的管理问题。\n《抉择》：决策的智慧 在《抉择》中，高德拉特探讨了决策过程中的复杂性。这本书让我理解到，面对选择时，我们需要考虑长远的影响，而不仅仅是眼前的利益。\n核心观点 TOC四大支柱：书中通过对话形式阐述了TOC（Theory of Constraints，制约理论）的四大支柱信念。 逻辑思维与决策：强调逻辑思维在分析和解决企业与个人问题中的重要性。 双赢与人际关系：探讨了如何在冲突中寻求双赢的解决方案，以及如何建立和谐的人际关系。 简单性与复杂性：揭示了所有系统的固有简单性，鼓励读者跳出固有的思维框架，简化复杂问题。 故事背景 对话形式：艾利·高德拉特博士与其女儿的对话，以轻松风趣的方式探讨深奥的管理与人生哲学。 案例分析：书中包含了多个企业管理的案例，展示了TOC理论在实际应用中的效果。 主要内容 第一部分：服装公司案例，展示了TOC理论在实际企业运营中的应用。 第二部分：面包公司案例，进一步阐释TOC理论在不同行业中的应用。 第三部分：对人性的深刻洞见，探讨了人性中的善良、冲突的可解性、情况的简单性以及改善的可能性。 结果 通过对话和案例分析，读者能够理解并应用TOC理论来提升个人和企业的决策质量，实现更高的目标。 核心理念 固有简单性：所有看似复杂的问题都有其简单的本质，通过正确的逻辑思维可以找到解决方案。 和谐与冲突：在人际关系和企业运营中，追求和谐的同时，勇于面对和解决冲突是实现双赢的关键。 持续学习与实践：TOC理论的学习是一个持续的过程，需要不断地实践和探索。 《抉择》不仅是艾利·高德拉特博士对TOC理论的深入阐述，也是他对个人成长和企业成功哲学的深刻反思。通过书中的对话和案例，读者可以获得宝贵的思维工具和生活智慧。\n“目标不仅仅是一个愿望，它是一个承诺。” —— 艾利·高德拉特\n","date":"2024-02-29T00:00:00Z","image":"https://www.wenke-chen.github.io/p/reading-notes-1/dream_hu7ef17007a5f581a8c43b82dee8cc313c_54252_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.wenke-chen.github.io/p/reading-notes-1/","title":"艾利·高德拉特的智慧之旅：《目标》系列读后感"}]